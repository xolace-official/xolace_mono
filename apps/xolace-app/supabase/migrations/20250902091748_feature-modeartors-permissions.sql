create type "public"."campfire_permission" as enum ('manage_config', 'manage_content', 'manage_users');

create type "public"."moderation_action_type" as enum ('ban_user_temporary', 'ban_user_permanent', 'unban_user', 'mute_user_temporary', 'mute_user_permanent', 'unmute_user', 'remove_member', 'delete_post', 'remove_post', 'restore_post', 'delete_comment', 'remove_comment', 'restore_comment', 'pin_comment', 'unpin_comment', 'grant_permission', 'revoke_permission');

create type "public"."moderation_duration_type" as enum ('temporary', 'permanent');

drop policy "Allow user to update own row" on "public"."campfire_members";

drop policy "Allow users to leave campfires" on "public"."campfire_members";

alter type "public"."notification_type" rename to "notification_type__old_version_to_be_dropped";

create type "public"."notification_type" as enum ('new_upvote', 'new_downvote', 'new_comment', 'post_saved', 'video_saved', 'video_liked', 'system_announcement', 'post_viewed', 'comment_reply', 'joined_campfire', 'leave_campfire', 'firekeeper_invitation');

create table "public"."campfire_member_permissions" (
    "campfire_id" uuid not null,
    "user_id" uuid not null,
    "permission_id" bigint not null,
    "allowed" boolean not null default true,
    "granted_by" uuid not null,
    "granted_at" timestamp with time zone not null default now(),
    "expires_at" timestamp with time zone,
    "notes" text
);


alter table "public"."campfire_member_permissions" enable row level security;

create table "public"."campfire_member_restrictions" (
    "id" uuid not null default gen_random_uuid(),
    "campfire_id" uuid not null,
    "user_id" uuid not null,
    "restricted_by" uuid not null,
    "restriction_type" text not null,
    "duration_type" moderation_duration_type not null,
    "expires_at" timestamp with time zone,
    "reason" text not null,
    "created_at" timestamp with time zone not null default now(),
    "lifted_at" timestamp with time zone,
    "lifted_by" uuid,
    "lift_reason" text
);


alter table "public"."campfire_member_restrictions" enable row level security;

create table "public"."campfire_moderation_logs" (
    "id" uuid not null default gen_random_uuid(),
    "campfire_id" uuid not null,
    "moderator_id" uuid not null,
    "target_user_id" uuid,
    "target_post_id" uuid,
    "target_comment_id" bigint,
    "permission_id" bigint,
    "action_type" moderation_action_type not null,
    "reason" text not null,
    "additional_notes" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."campfire_moderation_logs" enable row level security;

create table "public"."campfire_moderator_invites" (
    "id" uuid not null default gen_random_uuid(),
    "campfire_id" uuid not null,
    "inviter_id" uuid not null,
    "invitee_id" uuid not null,
    "permission_ids" bigint[] not null,
    "expires_at" timestamp with time zone not null,
    "accepted_at" timestamp with time zone,
    "declined_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "invitation_message" text
);


alter table "public"."campfire_moderator_invites" enable row level security;

create table "public"."campfire_permissions" (
    "id" bigint generated by default as identity not null,
    "key" text not null,
    "display_name" text not null,
    "description" text,
    "permission_group" campfire_permission not null,
    "is_active" boolean not null default true,
    "sort_order" integer not null default 0,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."campfire_permissions" enable row level security;

create table "public"."campfire_settings" (
    "campfire_id" uuid not null,
    "firekeeper_invite_expiry_days" integer not null default 7,
    "auto_remove_expired_restrictions" boolean not null default true,
    "max_firekeepers" integer not null default 10,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."campfire_settings" enable row level security;

alter table "public"."notifications" alter column type type "public"."notification_type" using type::text::"public"."notification_type";

drop type "public"."notification_type__old_version_to_be_dropped";

alter table "public"."campfire_members" add column "is_approved" boolean not null default false;

CREATE UNIQUE INDEX campfire_member_permissions_pkey ON public.campfire_member_permissions USING btree (campfire_id, user_id, permission_id);

CREATE UNIQUE INDEX campfire_member_restrictions_pkey ON public.campfire_member_restrictions USING btree (id);

CREATE UNIQUE INDEX campfire_moderation_logs_pkey ON public.campfire_moderation_logs USING btree (id);

CREATE UNIQUE INDEX campfire_moderator_invites_pkey ON public.campfire_moderator_invites USING btree (id);

CREATE UNIQUE INDEX campfire_permissions_key_key ON public.campfire_permissions USING btree (key);

CREATE UNIQUE INDEX campfire_permissions_pkey ON public.campfire_permissions USING btree (id);

CREATE UNIQUE INDEX campfire_settings_pkey ON public.campfire_settings USING btree (campfire_id);

CREATE UNIQUE INDEX cmr_unique ON public.campfire_member_restrictions USING btree (campfire_id, user_id, restriction_type);

CREATE INDEX idx_campfire_permissions_group ON public.campfire_permissions USING btree (permission_group);

CREATE INDEX idx_campfire_permissions_key ON public.campfire_permissions USING btree (key);

CREATE INDEX idx_cmi_pending ON public.campfire_moderator_invites USING btree (invitee_id, expires_at) WHERE ((accepted_at IS NULL) AND (declined_at IS NULL));

CREATE INDEX idx_cml_campfire_date ON public.campfire_moderation_logs USING btree (campfire_id, created_at DESC);

CREATE INDEX idx_cml_moderator ON public.campfire_moderation_logs USING btree (moderator_id, created_at DESC);

CREATE INDEX idx_cml_permission ON public.campfire_moderation_logs USING btree (permission_id) WHERE (permission_id IS NOT NULL);

CREATE INDEX idx_cmp_active_permissions ON public.campfire_member_permissions USING btree (campfire_id, user_id) WHERE ((allowed = true) AND (expires_at IS NULL));

CREATE INDEX idx_cmp_campfire_user ON public.campfire_member_permissions USING btree (campfire_id, user_id);

CREATE INDEX idx_cmp_permission ON public.campfire_member_permissions USING btree (permission_id);

CREATE INDEX idx_cmp_user_campfire ON public.campfire_member_permissions USING btree (user_id, campfire_id);

CREATE INDEX idx_cmr_active ON public.campfire_member_restrictions USING btree (campfire_id, user_id, restriction_type) WHERE (lifted_at IS NULL);

alter table "public"."campfire_member_permissions" add constraint "campfire_member_permissions_pkey" PRIMARY KEY using index "campfire_member_permissions_pkey";

alter table "public"."campfire_member_restrictions" add constraint "campfire_member_restrictions_pkey" PRIMARY KEY using index "campfire_member_restrictions_pkey";

alter table "public"."campfire_moderation_logs" add constraint "campfire_moderation_logs_pkey" PRIMARY KEY using index "campfire_moderation_logs_pkey";

alter table "public"."campfire_moderator_invites" add constraint "campfire_moderator_invites_pkey" PRIMARY KEY using index "campfire_moderator_invites_pkey";

alter table "public"."campfire_permissions" add constraint "campfire_permissions_pkey" PRIMARY KEY using index "campfire_permissions_pkey";

alter table "public"."campfire_settings" add constraint "campfire_settings_pkey" PRIMARY KEY using index "campfire_settings_pkey";

alter table "public"."campfire_member_permissions" add constraint "cmp_campfire_fkey" FOREIGN KEY (campfire_id) REFERENCES campfires(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_member_permissions" validate constraint "cmp_campfire_fkey";

alter table "public"."campfire_member_permissions" add constraint "cmp_granted_by_fkey" FOREIGN KEY (granted_by) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_member_permissions" validate constraint "cmp_granted_by_fkey";

alter table "public"."campfire_member_permissions" add constraint "cmp_permission_fkey" FOREIGN KEY (permission_id) REFERENCES campfire_permissions(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_member_permissions" validate constraint "cmp_permission_fkey";

alter table "public"."campfire_member_permissions" add constraint "cmp_user_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_member_permissions" validate constraint "cmp_user_fkey";

alter table "public"."campfire_member_restrictions" add constraint "check_permanent_no_expiry" CHECK ((((duration_type = 'permanent'::moderation_duration_type) AND (expires_at IS NULL)) OR ((duration_type = 'temporary'::moderation_duration_type) AND (expires_at IS NOT NULL)))) not valid;

alter table "public"."campfire_member_restrictions" validate constraint "check_permanent_no_expiry";

alter table "public"."campfire_member_restrictions" add constraint "check_restriction_type" CHECK ((restriction_type = ANY (ARRAY['ban'::text, 'mute'::text]))) not valid;

alter table "public"."campfire_member_restrictions" validate constraint "check_restriction_type";

alter table "public"."campfire_member_restrictions" add constraint "cmr_campfire_fkey" FOREIGN KEY (campfire_id) REFERENCES campfires(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_member_restrictions" validate constraint "cmr_campfire_fkey";

alter table "public"."campfire_member_restrictions" add constraint "cmr_lifted_by_fkey" FOREIGN KEY (lifted_by) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_member_restrictions" validate constraint "cmr_lifted_by_fkey";

alter table "public"."campfire_member_restrictions" add constraint "cmr_restricted_by_fkey" FOREIGN KEY (restricted_by) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_member_restrictions" validate constraint "cmr_restricted_by_fkey";

alter table "public"."campfire_member_restrictions" add constraint "cmr_unique" UNIQUE using index "cmr_unique";

alter table "public"."campfire_member_restrictions" add constraint "cmr_user_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_member_restrictions" validate constraint "cmr_user_fkey";

alter table "public"."campfire_moderation_logs" add constraint "cml_campfire_fkey" FOREIGN KEY (campfire_id) REFERENCES campfires(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_moderation_logs" validate constraint "cml_campfire_fkey";

alter table "public"."campfire_moderation_logs" add constraint "cml_moderator_fkey" FOREIGN KEY (moderator_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_moderation_logs" validate constraint "cml_moderator_fkey";

alter table "public"."campfire_moderation_logs" add constraint "cml_permission_fkey" FOREIGN KEY (permission_id) REFERENCES campfire_permissions(id) ON DELETE SET NULL not valid;

alter table "public"."campfire_moderation_logs" validate constraint "cml_permission_fkey";

alter table "public"."campfire_moderation_logs" add constraint "cml_target_comment_fkey" FOREIGN KEY (target_comment_id) REFERENCES comments(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_moderation_logs" validate constraint "cml_target_comment_fkey";

alter table "public"."campfire_moderation_logs" add constraint "cml_target_post_fkey" FOREIGN KEY (target_post_id) REFERENCES posts(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_moderation_logs" validate constraint "cml_target_post_fkey";

alter table "public"."campfire_moderation_logs" add constraint "cml_target_user_fkey" FOREIGN KEY (target_user_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_moderation_logs" validate constraint "cml_target_user_fkey";

alter table "public"."campfire_moderator_invites" add constraint "check_not_expired" CHECK ((expires_at > created_at)) not valid;

alter table "public"."campfire_moderator_invites" validate constraint "check_not_expired";

alter table "public"."campfire_moderator_invites" add constraint "check_single_response" CHECK ((((accepted_at IS NULL) AND (declined_at IS NULL)) OR ((accepted_at IS NOT NULL) AND (declined_at IS NULL)) OR ((accepted_at IS NULL) AND (declined_at IS NOT NULL)))) not valid;

alter table "public"."campfire_moderator_invites" validate constraint "check_single_response";

alter table "public"."campfire_moderator_invites" add constraint "cmi_campfire_fkey" FOREIGN KEY (campfire_id) REFERENCES campfires(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_moderator_invites" validate constraint "cmi_campfire_fkey";

alter table "public"."campfire_moderator_invites" add constraint "cmi_invitee_fkey" FOREIGN KEY (invitee_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_moderator_invites" validate constraint "cmi_invitee_fkey";

alter table "public"."campfire_moderator_invites" add constraint "cmi_inviter_fkey" FOREIGN KEY (inviter_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_moderator_invites" validate constraint "cmi_inviter_fkey";

alter table "public"."campfire_permissions" add constraint "campfire_permissions_key_check" CHECK ((key ~ '^[a-z_]+$'::text)) not valid;

alter table "public"."campfire_permissions" validate constraint "campfire_permissions_key_check";

alter table "public"."campfire_permissions" add constraint "campfire_permissions_key_key" UNIQUE using index "campfire_permissions_key_key";

alter table "public"."campfire_settings" add constraint "campfire_settings_campfire_id_fkey" FOREIGN KEY (campfire_id) REFERENCES campfires(id) ON DELETE CASCADE not valid;

alter table "public"."campfire_settings" validate constraint "campfire_settings_campfire_id_fkey";

alter table "public"."campfire_settings" add constraint "check_invite_expiry_positive" CHECK ((firekeeper_invite_expiry_days > 0)) not valid;

alter table "public"."campfire_settings" validate constraint "check_invite_expiry_positive";

alter table "public"."campfire_settings" add constraint "check_max_moderators_positive" CHECK ((max_firekeepers > 0)) not valid;

alter table "public"."campfire_settings" validate constraint "check_max_moderators_positive";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.accept_firekeeper_invitation(p_invitation_id uuid, p_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$DECLARE
  v_invite_record record;
BEGIN
  -- Get invitation details
  SELECT * INTO v_invite_record
  FROM public.campfire_moderator_invites
  WHERE id = p_invitation_id
  AND invitee_id = p_user_id
  AND expires_at > now()
  AND accepted_at IS NULL
  AND declined_at IS NULL;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Invalid or expired invitation';
  END IF;

  -- Add user to campfire as member if not already
  INSERT INTO public.campfire_members (campfire_id, user_id, role)
  VALUES (v_invite_record.campfire_id, p_user_id, 'firekeeper')
  ON CONFLICT (campfire_id, user_id) 
  DO UPDATE SET role = EXCLUDED.role
  WHERE campfire_members.role <> 'firestarter';

  -- Grant permissions
  INSERT INTO public.campfire_member_permissions (
    campfire_id, user_id, permission_id, granted_by
  )
  SELECT 
    v_invite_record.campfire_id, 
    p_user_id, 
    unnest(v_invite_record.permission_ids),
    v_invite_record.inviter_id
  ON CONFLICT (campfire_id, user_id, permission_id) DO NOTHING;

  -- Mark invitation as accepted
  UPDATE public.campfire_moderator_invites
  SET accepted_at = now()
  WHERE id = p_invitation_id;

  -- Log the action
  INSERT INTO public.campfire_moderation_logs (
    campfire_id, moderator_id, target_user_id, action_type, reason
  ) VALUES (
    v_invite_record.campfire_id, v_invite_record.inviter_id, p_user_id,
    'grant_permission', 'Firekeeper invitation accepted'
  );

  RETURN true;
END;$function$
;

CREATE OR REPLACE FUNCTION public.create_default_campfire_settings()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO public.campfire_settings (campfire_id)
  VALUES (NEW.id);
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_firekeeper_invitation(p_campfire_id uuid, p_inviter_id uuid, p_invitee_id uuid, p_permission_ids bigint[], p_invitation_message text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$DECLARE
  v_invitation_id uuid;
  v_current_firekeeper_count integer;
  v_max_firekeepers integer;
  v_campfire_name text;
  v_campfire_slug text;
  v_campfire_icon_url text;
BEGIN
  -- Your existing checks for permissions and limits remain the same...
  IF NOT public.has_campfire_permission(p_campfire_id, p_inviter_id, 'can_manage_roles') THEN
    RAISE EXCEPTION 'Insufficient permissions to invite firekeepers';
  END IF;

  SELECT cs.max_firekeepers INTO v_max_firekeepers FROM public.campfire_settings cs WHERE cs.campfire_id = p_campfire_id;
  SELECT COUNT(*) INTO v_current_firekeeper_count FROM public.campfire_members WHERE campfire_id = p_campfire_id AND role = 'firekeeper';

  IF v_current_firekeeper_count >= v_max_firekeepers THEN
    RAISE EXCEPTION 'Maximum number of firekeepers reached';
  END IF;

  -- Get Campfire details for the notification
  SELECT name, icon_url, slug INTO v_campfire_name, v_campfire_icon_url, v_campfire_slug
  FROM public.campfires WHERE id = p_campfire_id;

  -- Create invitation
  INSERT INTO public.campfire_moderator_invites (
    campfire_id, inviter_id, invitee_id, permission_ids,
    expires_at, invitation_message
  ) VALUES (
    p_campfire_id, p_inviter_id, p_invitee_id, p_permission_ids,
    now() + interval '7 days', p_invitation_message
  ) RETURNING id INTO v_invitation_id;

  -- Create notification for invitee with richer metadata
  INSERT INTO public.notifications (
    recipient_user_id, actor_id, type, entity_id, metadata
  ) VALUES (
    p_invitee_id, p_inviter_id, 'firekeeper_invitation',
    v_invitation_id::text,
    jsonb_build_object(
      'campfire_id', p_campfire_id,
      'campfire_name', v_campfire_name, -- Added
      'campfire_slug', v_campfire_slug,
      'campfire_icon_url', v_campfire_icon_url, -- Added
      'invitation_message', p_invitation_message
    )
  );
  RETURN v_invitation_id;
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_campfire_approved_users(p_campfire_id uuid)
 RETURNS TABLE(id uuid, username text, avatar_url text, joined_at timestamp with time zone, reputation bigint)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.username,
    COALESCE(p.avatar_url, '') as avatar_url,
    cm.joined_at,
    p.reputation
  FROM public.campfire_members cm
  JOIN public.profiles p ON p.id = cm.user_id
  WHERE cm.campfire_id = p_campfire_id
    AND cm.is_approved = true
  ORDER BY cm.joined_at ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_campfire_moderators(p_campfire_id uuid)
 RETURNS TABLE(id uuid, username text, avatar_url text, role campfire_role, joined_at timestamp with time zone, permission_summary text, permission_count integer, can_edit boolean, permissions jsonb)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  viewer_user_id uuid;
  viewer_can_manage_roles boolean := false;
BEGIN
  -- Get the viewer's user_id from auth.uid() via profiles table
  SELECT p.id INTO viewer_user_id
  FROM public.profiles p
  WHERE p.supabase_user = auth.uid();
  
  -- If no viewer found, return empty result
  IF viewer_user_id IS NULL THEN
    RETURN;
  END IF;
  
  -- Check if the viewer has can_manage_roles permission for this campfire
  SELECT EXISTS(
    SELECT 1
    FROM public.campfire_members cm
    LEFT JOIN public.campfire_member_permissions cmp ON (
      cmp.campfire_id = cm.campfire_id 
      AND cmp.user_id = cm.user_id 
      AND cmp.allowed = true 
      AND (cmp.expires_at IS NULL OR cmp.expires_at > now())
    )
    LEFT JOIN public.campfire_permissions cp ON cp.id = cmp.permission_id
    WHERE cm.campfire_id = p_campfire_id
      AND cm.user_id = viewer_user_id
      AND (
        -- Firestarter has all permissions
        cm.role = 'firestarter'
        OR 
        -- Or has explicit can_manage_roles permission
        (cp.key = 'can_manage_roles' AND cp.is_active = true)
      )
  ) INTO viewer_can_manage_roles;

  RETURN QUERY
  WITH moderator_permissions AS (
    SELECT
      cm.user_id,
      cm.role,
      cm.joined_at,
      -- Get permissions for firekeepers; creators have all permissions
      CASE
        WHEN cm.role = 'firestarter' THEN
          (SELECT array_agg(cp.id) FROM public.campfire_permissions cp WHERE cp.is_active = true)
        ELSE
          -- Get permissions from the normalized permissions table
          (
            SELECT array_agg(cmp.permission_id)
            FROM public.campfire_member_permissions cmp
            WHERE cmp.campfire_id = cm.campfire_id
              AND cmp.user_id = cm.user_id
              AND cmp.allowed = true
              AND (cmp.expires_at IS NULL OR cmp.expires_at > now())
          )
      END as user_permissions
    FROM public.campfire_members cm
    WHERE cm.campfire_id = p_campfire_id
      AND cm.role IN ('firestarter', 'firekeeper')
  ),
  permission_details AS (
    SELECT
      mp.user_id,
      mp.role,
      mp.joined_at,
      mp.user_permissions,
      COALESCE(array_length(mp.user_permissions, 1), 0) as perm_count,
      CASE
        WHEN mp.role = 'firestarter' THEN 'Everything'
        WHEN mp.user_permissions IS NULL OR array_length(mp.user_permissions, 1) = 0 THEN 'No permissions'
        ELSE
          (
            SELECT string_agg(DISTINCT cp.permission_group::text, ', ')
            FROM public.campfire_permissions cp
            WHERE cp.id = ANY(mp.user_permissions) AND cp.is_active = true
          )
      END as perm_summary,
      CASE
        WHEN mp.user_permissions IS NOT NULL THEN
          (
            SELECT jsonb_agg(
              jsonb_build_object(
                'id', cp.id,
                'key', cp.key,
                'display_name', cp.display_name,
                'permission_group', cp.permission_group
              )
              ORDER BY cp.sort_order
            )
            FROM public.campfire_permissions cp
            WHERE cp.id = ANY(mp.user_permissions) AND cp.is_active = true
          )
        ELSE '[]'::jsonb
      END as perm_details
    FROM moderator_permissions mp
  )
  SELECT
    p.id,
    p.username,
    COALESCE(p.avatar_url, '') as avatar_url,
    pd.role,
    pd.joined_at,
    COALESCE(pd.perm_summary, 'No permissions') as permission_summary,
    pd.perm_count as permission_count,
    -- REFACTORED: Viewer-centric can_edit logic
    CASE
      -- Firestarters are NEVER editable
      WHEN pd.role = 'firestarter' THEN false
      -- Users cannot edit their own permissions
      WHEN pd.user_id = viewer_user_id THEN false
      -- For other firekeepers, depends on viewer's permission
      ELSE viewer_can_manage_roles
    END as can_edit,
    COALESCE(pd.perm_details, '[]'::jsonb) as permissions
  FROM permission_details pd
  JOIN public.profiles p ON p.id = pd.user_id
  ORDER BY
    CASE pd.role
      WHEN 'firestarter' THEN 1
      WHEN 'firekeeper' THEN 2
      ELSE 3
    END,
    pd.joined_at ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_campfire_moderators_v2(p_campfire_id uuid)
 RETURNS TABLE(id uuid, username text, avatar_url text, role campfire_role, joined_at timestamp with time zone, permission_summary text, permission_count integer, can_edit boolean, permissions jsonb)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$BEGIN
  RETURN QUERY
  WITH moderator_permissions AS (
    SELECT
      cm.user_id,
      cm.role,
      cm.joined_at, -- Use joined_at directly from the table
      -- Get permissions for firekeepers; creators have all permissions
      CASE
        WHEN cm.role = 'firestarter' THEN -- Use 'firestarter' as per your has_campfire_permission func
          (SELECT array_agg(cp.id) FROM public.campfire_permissions cp WHERE cp.is_active = true)
        ELSE
          -- =================================================================
          -- ## REFACTORED PART ##
          -- Instead of reading a column, we now build the array directly
          -- from your correct, normalized permissions table.
          (
            SELECT array_agg(cmp.permission_id)
            FROM public.campfire_member_permissions cmp
            WHERE cmp.campfire_id = cm.campfire_id
              AND cmp.user_id = cm.user_id
              AND cmp.allowed = true
              AND (cmp.expires_at IS NULL OR cmp.expires_at > now())
          )
          -- =================================================================
      END as user_permissions
    FROM public.campfire_members cm
    WHERE cm.campfire_id = p_campfire_id
      AND cm.role IN ('firestarter', 'firekeeper') -- Matched to your actual roles
  ),
  permission_details AS (
    -- This entire CTE remains the same as it correctly processes the array
    SELECT
      mp.user_id,
      mp.role,
      mp.joined_at,
      mp.user_permissions,
      COALESCE(array_length(mp.user_permissions, 1), 0) as perm_count,
      CASE
        WHEN mp.role = 'firestarter' THEN 'Everything'
        WHEN mp.user_permissions IS NULL OR array_length(mp.user_permissions, 1) = 0 THEN 'No permissions'
        ELSE
          (
            SELECT string_agg(DISTINCT cp.permission_group::text, ', ')
            FROM public.campfire_permissions cp
            WHERE cp.id = ANY(mp.user_permissions) AND cp.is_active = true
          )
      END as perm_summary,
      CASE
        WHEN mp.user_permissions IS NOT NULL THEN
          (
            SELECT jsonb_agg(
              jsonb_build_object(
                'id', cp.id,
                'key', cp.key,
                'display_name', cp.display_name,
                'permission_group', cp.permission_group
              )
              ORDER BY cp.sort_order
            )
            FROM public.campfire_permissions cp
            WHERE cp.id = ANY(mp.user_permissions) AND cp.is_active = true
          )
        ELSE '[]'::jsonb
      END as perm_details
    FROM moderator_permissions mp
  )
  -- This final SELECT also remains mostly the same
  SELECT
    p.id,
    p.username,
    COALESCE(p.avatar_url, '') as avatar_url,
    pd.role,
    pd.joined_at,
    COALESCE(pd.perm_summary, 'No permissions') as permission_summary,
    pd.perm_count as permission_count,
    CASE
      WHEN pd.role = 'firestarter' THEN true
      WHEN pd.user_permissions IS NULL THEN false
      ELSE EXISTS(
        SELECT 1 FROM public.campfire_permissions cp
        WHERE cp.key = 'can_manage_roles' -- Assumes this key exists
          AND cp.id = ANY(pd.user_permissions)
          AND cp.is_active = true
      )
    END as can_edit,
    COALESCE(pd.perm_details, '[]'::jsonb) as permissions
  FROM permission_details pd
  JOIN public.profiles p ON p.id = pd.user_id
  ORDER BY
    CASE pd.role
      WHEN 'firestarter' THEN 1
      WHEN 'firekeeper' THEN 2
      ELSE 3
    END,
    pd.joined_at ASC;
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_campfire_moderators_v3(p_campfire_id uuid)
 RETURNS TABLE(id uuid, username text, avatar_url text, role campfire_role, joined_at timestamp with time zone, permission_summary text, permission_count integer, can_edit boolean, permissions jsonb)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$DECLARE
  viewer_user_id uuid;
  viewer_can_manage_roles boolean := false;
BEGIN
  -- Get the viewer's user_id from auth.uid() via profiles table
  SELECT p.id INTO viewer_user_id
  FROM public.profiles p
  WHERE p.supabase_user = auth.uid();
  
  -- If no viewer found, return empty result
  IF viewer_user_id IS NULL THEN
    RETURN;
  END IF;
  
  -- Check if the viewer has can_manage_roles permission for this campfire
  SELECT EXISTS(
    SELECT 1
    FROM public.campfire_members cm
    LEFT JOIN public.campfire_member_permissions cmp ON (
      cmp.campfire_id = cm.campfire_id 
      AND cmp.user_id = cm.user_id 
      AND cmp.allowed = true 
      AND (cmp.expires_at IS NULL OR cmp.expires_at > now())
    )
    LEFT JOIN public.campfire_permissions cp ON cp.id = cmp.permission_id
    WHERE cm.campfire_id = p_campfire_id
      AND cm.user_id = viewer_user_id
      AND (
        -- Firestarter has all permissions
        cm.role = 'firestarter'
        OR 
        -- Or has explicit can_manage_roles permission
        (cp.key = 'can_manage_roles' AND cp.is_active = true)
      )
  ) INTO viewer_can_manage_roles;

  RETURN QUERY
  WITH moderator_permissions AS (
    SELECT
      cm.user_id,
      cm.role,
      cm.joined_at,
      -- Get permissions for firekeepers; creators have all permissions
      CASE
        WHEN cm.role = 'firestarter' THEN
          (SELECT array_agg(cp.id) FROM public.campfire_permissions cp WHERE cp.is_active = true)
        ELSE
          -- Get permissions from the normalized permissions table
          (
            SELECT array_agg(cmp.permission_id)
            FROM public.campfire_member_permissions cmp
            WHERE cmp.campfire_id = cm.campfire_id
              AND cmp.user_id = cm.user_id
              AND cmp.allowed = true
              AND (cmp.expires_at IS NULL OR cmp.expires_at > now())
          )
      END as user_permissions
    FROM public.campfire_members cm
    WHERE cm.campfire_id = p_campfire_id
      AND cm.role IN ('firestarter', 'firekeeper')
  ),
  permission_details AS (
    SELECT
      mp.user_id,
      mp.role,
      mp.joined_at,
      mp.user_permissions,
      COALESCE(array_length(mp.user_permissions, 1), 0) as perm_count,
      CASE
        WHEN mp.role = 'firestarter' THEN 'Everything'
        WHEN mp.user_permissions IS NULL OR array_length(mp.user_permissions, 1) = 0 THEN 'No permissions'
        ELSE
          (
            SELECT string_agg(DISTINCT cp.permission_group::text, ', ')
            FROM public.campfire_permissions cp
            WHERE cp.id = ANY(mp.user_permissions) AND cp.is_active = true
          )
      END as perm_summary,
      CASE
        WHEN mp.user_permissions IS NOT NULL THEN
          (
            SELECT jsonb_agg(
              jsonb_build_object(
                'id', cp.id,
                'key', cp.key,
                'display_name', cp.display_name,
                'permission_group', cp.permission_group
              )
              ORDER BY cp.sort_order
            )
            FROM public.campfire_permissions cp
            WHERE cp.id = ANY(mp.user_permissions) AND cp.is_active = true
          )
        ELSE '[]'::jsonb
      END as perm_details
    FROM moderator_permissions mp
  )
  SELECT
    p.id,
    p.username,
    COALESCE(p.avatar_url, '') as avatar_url,
    pd.role,
    pd.joined_at,
    COALESCE(pd.perm_summary, 'No permissions') as permission_summary,
    pd.perm_count as permission_count,
    -- REFACTORED: Viewer-centric can_edit logic
    CASE
      -- Firestarters are NEVER editable
      WHEN pd.role = 'firestarter' THEN false
      -- For firekeepers, depends on viewer's permission
      ELSE viewer_can_manage_roles
    END as can_edit,
    COALESCE(pd.perm_details, '[]'::jsonb) as permissions
  FROM permission_details pd
  JOIN public.profiles p ON p.id = pd.user_id
  ORDER BY
    CASE pd.role
      WHEN 'firestarter' THEN 1
      WHEN 'firekeeper' THEN 2
      ELSE 3
    END,
    pd.joined_at ASC;
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_user_campfire_permissions(p_campfire_id uuid)
 RETURNS TABLE(permission_key text, display_name text, permission_group text)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  v_user_id uuid;
BEGIN
  -- Resolve profile ID from supabase_user
  SELECT id INTO v_user_id
  FROM public.profiles
  WHERE supabase_user = auth.uid();

  IF p_campfire_id IS NULL OR v_user_id IS NULL THEN
    RETURN; -- Empty result set
  END IF;

  -- Firestarter gets all active permissions
  IF EXISTS (
    SELECT 1
    FROM public.campfire_members 
    WHERE campfire_id = p_campfire_id 
      AND user_id = v_user_id 
      AND role = 'firestarter'
  ) THEN
    RETURN QUERY
    SELECT cp.key, cp.display_name, cp.permission_group
    FROM public.campfire_permissions cp
    WHERE cp.is_active = true
    ORDER BY cp.permission_group, cp.sort_order;

  ELSE
    -- Firekeeper (and others) get explicitly granted permissions
    RETURN QUERY
    SELECT cp.key, cp.display_name, cp.permission_group
    FROM public.campfire_member_permissions cmp
    JOIN public.campfire_permissions cp 
      ON cmp.permission_id = cp.id
    WHERE cmp.campfire_id = p_campfire_id
      AND cmp.user_id = v_user_id
      AND cmp.allowed = true
      AND (cmp.expires_at IS NULL OR cmp.expires_at > now())
      AND cp.is_active = true
    ORDER BY cp.permission_group, cp.sort_order;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_campfire_permission(p_campfire_id uuid, p_user_id uuid, p_permission_key text)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$BEGIN
  -- Firestarter always has all permissions
  IF EXISTS (
    SELECT 1 FROM public.campfire_members 
    WHERE campfire_id = p_campfire_id 
    AND user_id = p_user_id 
    AND role = 'firestarter'
  ) THEN
    RETURN true;
  END IF;

  -- Check explicit permission grant for firekeepers
  RETURN EXISTS (
    SELECT 1 
    FROM public.campfire_member_permissions cmp
    JOIN public.campfire_permissions cp ON cmp.permission_id = cp.id
    JOIN public.campfire_members cm ON cm.campfire_id = cmp.campfire_id AND cm.user_id = cmp.user_id
    WHERE cmp.campfire_id = p_campfire_id
    AND cmp.user_id = p_user_id
    AND cp.key = p_permission_key
    AND cmp.allowed = true
    AND (cmp.expires_at IS NULL OR cmp.expires_at > now())
    AND cp.is_active = true
    AND cm.role = 'firekeeper'
  );
END;$function$
;

CREATE OR REPLACE FUNCTION public.is_active_campfire_member(p_campfire_id uuid, p_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE
 SET search_path TO ''
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.campfire_members cm
    WHERE cm.campfire_id = p_campfire_id
      AND cm.user_id = p_user_id
  )
  AND NOT EXISTS (
    SELECT 1
    FROM public.campfire_member_restrictions cmr
    WHERE cmr.campfire_id = p_campfire_id
      AND cmr.user_id = p_user_id
      AND cmr.restriction_type = 'ban'
      AND cmr.lifted_at IS NULL
      AND (cmr.expires_at IS NULL OR cmr.expires_at > now())
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.prevent_firestarter_restriction()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF EXISTS (
    SELECT 1 FROM public.campfire_members
    WHERE campfire_id = NEW.campfire_id
      AND user_id = NEW.user_id
      AND role = 'firestarter'
  ) THEN
    RAISE EXCEPTION 'Cannot restrict firestarters';
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_profiles_for_invite(p_search_term text)
 RETURNS TABLE(id uuid, username text, avatar_url text, created_at timestamp with time zone, reputation bigint)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
  -- We only return results if the search term is at least 3 characters long
  -- to avoid overly broad and inefficient queries.
  IF char_length(p_search_term) < 3 THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT
    p.id,
    p.username,
    p.avatar_url,
    p.created_at,
    p.reputation
  FROM public.profiles AS p
  WHERE
    p.is_anonymous = false
    AND p.username ILIKE p_search_term || '%' -- Use ILIKE for case-insensitive prefix search
  ORDER BY
    -- You could also order by reputation or another metric
    p.username
  LIMIT 4;
END;
$function$
;

grant delete on table "public"."campfire_member_permissions" to "anon";

grant insert on table "public"."campfire_member_permissions" to "anon";

grant references on table "public"."campfire_member_permissions" to "anon";

grant select on table "public"."campfire_member_permissions" to "anon";

grant trigger on table "public"."campfire_member_permissions" to "anon";

grant truncate on table "public"."campfire_member_permissions" to "anon";

grant update on table "public"."campfire_member_permissions" to "anon";

grant delete on table "public"."campfire_member_permissions" to "authenticated";

grant insert on table "public"."campfire_member_permissions" to "authenticated";

grant references on table "public"."campfire_member_permissions" to "authenticated";

grant select on table "public"."campfire_member_permissions" to "authenticated";

grant trigger on table "public"."campfire_member_permissions" to "authenticated";

grant truncate on table "public"."campfire_member_permissions" to "authenticated";

grant update on table "public"."campfire_member_permissions" to "authenticated";

grant delete on table "public"."campfire_member_permissions" to "service_role";

grant insert on table "public"."campfire_member_permissions" to "service_role";

grant references on table "public"."campfire_member_permissions" to "service_role";

grant select on table "public"."campfire_member_permissions" to "service_role";

grant trigger on table "public"."campfire_member_permissions" to "service_role";

grant truncate on table "public"."campfire_member_permissions" to "service_role";

grant update on table "public"."campfire_member_permissions" to "service_role";

grant delete on table "public"."campfire_member_restrictions" to "anon";

grant insert on table "public"."campfire_member_restrictions" to "anon";

grant references on table "public"."campfire_member_restrictions" to "anon";

grant select on table "public"."campfire_member_restrictions" to "anon";

grant trigger on table "public"."campfire_member_restrictions" to "anon";

grant truncate on table "public"."campfire_member_restrictions" to "anon";

grant update on table "public"."campfire_member_restrictions" to "anon";

grant delete on table "public"."campfire_member_restrictions" to "authenticated";

grant insert on table "public"."campfire_member_restrictions" to "authenticated";

grant references on table "public"."campfire_member_restrictions" to "authenticated";

grant select on table "public"."campfire_member_restrictions" to "authenticated";

grant trigger on table "public"."campfire_member_restrictions" to "authenticated";

grant truncate on table "public"."campfire_member_restrictions" to "authenticated";

grant update on table "public"."campfire_member_restrictions" to "authenticated";

grant delete on table "public"."campfire_member_restrictions" to "service_role";

grant insert on table "public"."campfire_member_restrictions" to "service_role";

grant references on table "public"."campfire_member_restrictions" to "service_role";

grant select on table "public"."campfire_member_restrictions" to "service_role";

grant trigger on table "public"."campfire_member_restrictions" to "service_role";

grant truncate on table "public"."campfire_member_restrictions" to "service_role";

grant update on table "public"."campfire_member_restrictions" to "service_role";

grant delete on table "public"."campfire_moderation_logs" to "anon";

grant insert on table "public"."campfire_moderation_logs" to "anon";

grant references on table "public"."campfire_moderation_logs" to "anon";

grant select on table "public"."campfire_moderation_logs" to "anon";

grant trigger on table "public"."campfire_moderation_logs" to "anon";

grant truncate on table "public"."campfire_moderation_logs" to "anon";

grant update on table "public"."campfire_moderation_logs" to "anon";

grant delete on table "public"."campfire_moderation_logs" to "authenticated";

grant insert on table "public"."campfire_moderation_logs" to "authenticated";

grant references on table "public"."campfire_moderation_logs" to "authenticated";

grant select on table "public"."campfire_moderation_logs" to "authenticated";

grant trigger on table "public"."campfire_moderation_logs" to "authenticated";

grant truncate on table "public"."campfire_moderation_logs" to "authenticated";

grant update on table "public"."campfire_moderation_logs" to "authenticated";

grant delete on table "public"."campfire_moderation_logs" to "service_role";

grant insert on table "public"."campfire_moderation_logs" to "service_role";

grant references on table "public"."campfire_moderation_logs" to "service_role";

grant select on table "public"."campfire_moderation_logs" to "service_role";

grant trigger on table "public"."campfire_moderation_logs" to "service_role";

grant truncate on table "public"."campfire_moderation_logs" to "service_role";

grant update on table "public"."campfire_moderation_logs" to "service_role";

grant delete on table "public"."campfire_moderator_invites" to "anon";

grant insert on table "public"."campfire_moderator_invites" to "anon";

grant references on table "public"."campfire_moderator_invites" to "anon";

grant select on table "public"."campfire_moderator_invites" to "anon";

grant trigger on table "public"."campfire_moderator_invites" to "anon";

grant truncate on table "public"."campfire_moderator_invites" to "anon";

grant update on table "public"."campfire_moderator_invites" to "anon";

grant delete on table "public"."campfire_moderator_invites" to "authenticated";

grant insert on table "public"."campfire_moderator_invites" to "authenticated";

grant references on table "public"."campfire_moderator_invites" to "authenticated";

grant select on table "public"."campfire_moderator_invites" to "authenticated";

grant trigger on table "public"."campfire_moderator_invites" to "authenticated";

grant truncate on table "public"."campfire_moderator_invites" to "authenticated";

grant update on table "public"."campfire_moderator_invites" to "authenticated";

grant delete on table "public"."campfire_moderator_invites" to "service_role";

grant insert on table "public"."campfire_moderator_invites" to "service_role";

grant references on table "public"."campfire_moderator_invites" to "service_role";

grant select on table "public"."campfire_moderator_invites" to "service_role";

grant trigger on table "public"."campfire_moderator_invites" to "service_role";

grant truncate on table "public"."campfire_moderator_invites" to "service_role";

grant update on table "public"."campfire_moderator_invites" to "service_role";

grant delete on table "public"."campfire_permissions" to "anon";

grant insert on table "public"."campfire_permissions" to "anon";

grant references on table "public"."campfire_permissions" to "anon";

grant select on table "public"."campfire_permissions" to "anon";

grant trigger on table "public"."campfire_permissions" to "anon";

grant truncate on table "public"."campfire_permissions" to "anon";

grant update on table "public"."campfire_permissions" to "anon";

grant delete on table "public"."campfire_permissions" to "authenticated";

grant insert on table "public"."campfire_permissions" to "authenticated";

grant references on table "public"."campfire_permissions" to "authenticated";

grant select on table "public"."campfire_permissions" to "authenticated";

grant trigger on table "public"."campfire_permissions" to "authenticated";

grant truncate on table "public"."campfire_permissions" to "authenticated";

grant update on table "public"."campfire_permissions" to "authenticated";

grant delete on table "public"."campfire_permissions" to "service_role";

grant insert on table "public"."campfire_permissions" to "service_role";

grant references on table "public"."campfire_permissions" to "service_role";

grant select on table "public"."campfire_permissions" to "service_role";

grant trigger on table "public"."campfire_permissions" to "service_role";

grant truncate on table "public"."campfire_permissions" to "service_role";

grant update on table "public"."campfire_permissions" to "service_role";

grant delete on table "public"."campfire_settings" to "anon";

grant insert on table "public"."campfire_settings" to "anon";

grant references on table "public"."campfire_settings" to "anon";

grant select on table "public"."campfire_settings" to "anon";

grant trigger on table "public"."campfire_settings" to "anon";

grant truncate on table "public"."campfire_settings" to "anon";

grant update on table "public"."campfire_settings" to "anon";

grant delete on table "public"."campfire_settings" to "authenticated";

grant insert on table "public"."campfire_settings" to "authenticated";

grant references on table "public"."campfire_settings" to "authenticated";

grant select on table "public"."campfire_settings" to "authenticated";

grant trigger on table "public"."campfire_settings" to "authenticated";

grant truncate on table "public"."campfire_settings" to "authenticated";

grant update on table "public"."campfire_settings" to "authenticated";

grant delete on table "public"."campfire_settings" to "service_role";

grant insert on table "public"."campfire_settings" to "service_role";

grant references on table "public"."campfire_settings" to "service_role";

grant select on table "public"."campfire_settings" to "service_role";

grant trigger on table "public"."campfire_settings" to "service_role";

grant truncate on table "public"."campfire_settings" to "service_role";

grant update on table "public"."campfire_settings" to "service_role";

create policy "Enable insert for authenticated users only"
on "public"."campfire_member_permissions"
as permissive
for insert
to authenticated
with check (true);


create policy "Only role managers can DELETE permissions"
on "public"."campfire_member_permissions"
as permissive
for delete
to authenticated
using (has_campfire_permission(campfire_id, ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.supabase_user = ( SELECT auth.uid() AS uid))), 'can_manage_roles'::text));


create policy "Only role managers can modify permissions"
on "public"."campfire_member_permissions"
as permissive
for update
to authenticated
using (has_campfire_permission(campfire_id, ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.supabase_user = ( SELECT auth.uid() AS uid))), 'can_manage_roles'::text));


create policy "Unified permission visibility"
on "public"."campfire_member_permissions"
as permissive
for select
to authenticated
using ((rls_helpers.is_same_user(user_id) OR (EXISTS ( SELECT 1
   FROM (campfire_members cm
     JOIN profiles p ON ((cm.user_id = p.id)))
  WHERE ((cm.campfire_id = campfire_member_permissions.campfire_id) AND (p.supabase_user = ( SELECT auth.uid() AS uid)) AND ((cm.role = 'firestarter'::campfire_role) OR has_campfire_permission(cm.campfire_id, cm.user_id, 'can_manage_roles'::text)))))));


create policy "Moderators can see restrictions in their campfires"
on "public"."campfire_member_restrictions"
as permissive
for select
to authenticated
using ((has_campfire_permission(campfire_id, ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.supabase_user = ( SELECT auth.uid() AS uid))), 'can_ban_users'::text) OR has_campfire_permission(campfire_id, ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.supabase_user = ( SELECT auth.uid() AS uid))), 'can_mute_users'::text) OR rls_helpers.is_same_user(user_id)));


create policy "Moderators can see logs in their campfires"
on "public"."campfire_moderation_logs"
as permissive
for select
to authenticated
using ((EXISTS ( SELECT 1
   FROM (campfire_members cm
     JOIN profiles p ON ((cm.user_id = p.id)))
  WHERE ((cm.campfire_id = campfire_moderation_logs.campfire_id) AND (p.supabase_user = ( SELECT auth.uid() AS uid)) AND (cm.role = ANY (ARRAY['firestarter'::campfire_role, 'firekeeper'::campfire_role]))))));


create policy "Invitees can update their invites"
on "public"."campfire_moderator_invites"
as permissive
for update
to authenticated
using (rls_helpers.is_same_user(invitee_id));


create policy "Only role managers can create invites"
on "public"."campfire_moderator_invites"
as permissive
for insert
to authenticated
with check (has_campfire_permission(campfire_id, ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.supabase_user = ( SELECT auth.uid() AS uid))), 'can_manage_roles'::text));


create policy "Users can see invites they sent or received"
on "public"."campfire_moderator_invites"
as permissive
for select
to authenticated
using (((inviter_id = ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.supabase_user = ( SELECT auth.uid() AS uid)))) OR (invitee_id = ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.supabase_user = ( SELECT auth.uid() AS uid))))));


create policy "Auth users can read active permissions"
on "public"."campfire_permissions"
as permissive
for select
to authenticated
using ((is_active = true));


create policy "Settings managers can see and modify settings"
on "public"."campfire_settings"
as permissive
for all
to authenticated
using (has_campfire_permission(campfire_id, ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.supabase_user = ( SELECT auth.uid() AS uid))), 'can_edit_settings'::text));


create policy "Enable update for auth users "
on "public"."campfires"
as permissive
for update
to authenticated
using (true);


create policy "Allow user to update own row"
on "public"."campfire_members"
as permissive
for update
to authenticated
using ((rls_helpers.is_same_user(user_id) OR has_campfire_permission(campfire_id, user_id, 'can_manage_roles'::text)));


create policy "Allow users to leave campfires"
on "public"."campfire_members"
as permissive
for delete
to authenticated
using ((user_id = ( SELECT profiles.id
   FROM profiles
  WHERE (profiles.supabase_user = ( SELECT auth.uid() AS uid)))));


CREATE TRIGGER trg_prevent_firestarter_restriction BEFORE INSERT OR UPDATE ON public.campfire_member_restrictions FOR EACH ROW EXECUTE FUNCTION prevent_firestarter_restriction();

CREATE TRIGGER tr_create_default_campfire_settings AFTER INSERT ON public.campfires FOR EACH ROW EXECUTE FUNCTION create_default_campfire_settings();


set check_function_bodies = off;

CREATE OR REPLACE FUNCTION rls_helpers.is_campfire_member(p_campfire_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO ' '
AS $function$-- Check for the existence of a membership record
  -- that links the given campfire_id to the current user's profile.
  SELECT EXISTS (
    SELECT 1
    FROM public.campfire_members cm
    WHERE cm.campfire_id = p_campfire_id
      AND cm.user_id = (SELECT id FROM public.profiles WHERE supabase_user = (select auth.uid()))
  );$function$
;

CREATE OR REPLACE FUNCTION rls_helpers.is_same_user(profile_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$BEGIN
  RETURN (
    EXISTS (
      -- Qualify 'profiles' table with its schema (assuming 'public')
      SELECT FROM public.profiles WHERE id=profile_id AND supabase_user = (select auth.uid())
    )
  );
END;$function$
;



