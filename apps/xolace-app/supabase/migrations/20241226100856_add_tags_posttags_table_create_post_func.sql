create table "public"."posttags" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "tag" bigint not null,
    "post" uuid not null
);


alter table "public"."posttags" enable row level security;

create table "public"."tags" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "post" bigint not null default '0'::bigint
);


alter table "public"."tags" enable row level security;

CREATE UNIQUE INDEX posttags_pkey ON public.posttags USING btree (id);

CREATE UNIQUE INDEX tags_name_key ON public.tags USING btree (name);

CREATE UNIQUE INDEX tags_pkey ON public.tags USING btree (id);

alter table "public"."posttags" add constraint "posttags_pkey" PRIMARY KEY using index "posttags_pkey";

alter table "public"."tags" add constraint "tags_pkey" PRIMARY KEY using index "tags_pkey";

alter table "public"."posttags" add constraint "posttags_post_fkey" FOREIGN KEY (post) REFERENCES posts(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."posttags" validate constraint "posttags_post_fkey";

alter table "public"."posttags" add constraint "posttags_tag_fkey" FOREIGN KEY (tag) REFERENCES tags(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."posttags" validate constraint "posttags_tag_fkey";

alter table "public"."tags" add constraint "tags_name_key" UNIQUE using index "tags_name_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_post_with_tags(content text, mood post_mood, expires_in_24hr boolean, duration post_duration, expires_at timestamp with time zone, tag_names text[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
    post_id uuid;
    tag_id bigint;
    tag_name text;
BEGIN
    -- Start a transaction
    RAISE NOTICE 'Starting to create post with content: %', content;

    -- Insert the post
    INSERT INTO Posts ( content, mood, expires_in_24hr, duration, expires_at)
    VALUES ( content, mood, expires_in_24hr, duration, expires_at)
    RETURNING id INTO post_id;

    RAISE NOTICE 'Post created with ID: %', post_id;

    -- Loop through each tag name
    FOREACH tag_name IN ARRAY tag_names
    LOOP
        -- Check if the tag already exists
        INSERT INTO Tags (name, post)
        VALUES (tag_name, 1)
        ON CONFLICT (name)
        DO UPDATE SET post = Tags.post + 1
        RETURNING id INTO tag_id;

        -- Insert into PostTags
        INSERT INTO PostTags (tag , post) VALUES (tag_id, post_id);
            RAISE NOTICE 'PostTag created for post_id: % and tag_id: %', post_id, tag_id;
    END LOOP;


EXCEPTION 
    WHEN OTHERS THEN
        -- Rollback transaction in case of error
        RAISE NOTICE 'Transaction failed: %', SQLERRM;
        RETURN;
END;$function$
;

grant delete on table "public"."posttags" to "anon";

grant insert on table "public"."posttags" to "anon";

grant references on table "public"."posttags" to "anon";

grant select on table "public"."posttags" to "anon";

grant trigger on table "public"."posttags" to "anon";

grant truncate on table "public"."posttags" to "anon";

grant update on table "public"."posttags" to "anon";

grant delete on table "public"."posttags" to "authenticated";

grant insert on table "public"."posttags" to "authenticated";

grant references on table "public"."posttags" to "authenticated";

grant select on table "public"."posttags" to "authenticated";

grant trigger on table "public"."posttags" to "authenticated";

grant truncate on table "public"."posttags" to "authenticated";

grant update on table "public"."posttags" to "authenticated";

grant delete on table "public"."posttags" to "service_role";

grant insert on table "public"."posttags" to "service_role";

grant references on table "public"."posttags" to "service_role";

grant select on table "public"."posttags" to "service_role";

grant trigger on table "public"."posttags" to "service_role";

grant truncate on table "public"."posttags" to "service_role";

grant update on table "public"."posttags" to "service_role";

grant delete on table "public"."tags" to "anon";

grant insert on table "public"."tags" to "anon";

grant references on table "public"."tags" to "anon";

grant select on table "public"."tags" to "anon";

grant trigger on table "public"."tags" to "anon";

grant truncate on table "public"."tags" to "anon";

grant update on table "public"."tags" to "anon";

grant delete on table "public"."tags" to "authenticated";

grant insert on table "public"."tags" to "authenticated";

grant references on table "public"."tags" to "authenticated";

grant select on table "public"."tags" to "authenticated";

grant trigger on table "public"."tags" to "authenticated";

grant truncate on table "public"."tags" to "authenticated";

grant update on table "public"."tags" to "authenticated";

grant delete on table "public"."tags" to "service_role";

grant insert on table "public"."tags" to "service_role";

grant references on table "public"."tags" to "service_role";

grant select on table "public"."tags" to "service_role";

grant trigger on table "public"."tags" to "service_role";

grant truncate on table "public"."tags" to "service_role";

grant update on table "public"."tags" to "service_role";

create policy "Enable insert for authenticated users only"
on "public"."posttags"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."posttags"
as permissive
for select
to public
using (true);


create policy "Enable insert for authenticated users only"
on "public"."tags"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."tags"
as permissive
for select
to public
using (true);


create policy "Enable update to authenticated users only"
on "public"."tags"
as permissive
for update
to authenticated
using (true)
with check (true);




